# データ削除スクリプト（修正版）
# 管理者権限で実行される前提
# --- 安全策 ---
#  - 実行前に対象ユーザーとパスをログに出力している
#  - Built-in アカウント（Administrator / Default / Public）は削除しない保護あり
#  - 失敗時はログに例外メッセージを残す

$logPath = "C:\Windows\System32\CleanupLog.txt"

function Write-Log {
    param($Message)
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    "$timestamp - $Message" | Out-File -FilePath $logPath -Append -Encoding UTF8
}

Write-Log "=== クリーンアップ開始 ==="

try {
    # ------------------------------
    # 1) 現在コンソールにログインしている (インタラクティブ) ユーザーを取得
    # ------------------------------
    $userWithDomain = (Get-CimInstance -ClassName Win32_ComputerSystem).UserName
    if (-not $userWithDomain) {
        Write-Log "ERROR: コンソールログインユーザーが取得できませんでした。処理を中止します。"
        throw "Interactive user not found."
    }

    $currentUser = $userWithDomain.Split('\')[-1]
    Write-Log "検出されたインタラクティブユーザー: $currentUser"

    # ------------------------------
    # 2) そのユーザーのプロファイルパスを取得（Win32_UserProfile を優先）
    # ------------------------------
    $userProfilePath = $null
    try {
        $userProfilePath = Get-CimInstance -ClassName Win32_UserProfile `
            | Where-Object { $_.LocalPath -and ($_.LocalPath -match "\\$currentUser$") } `
            | Select-Object -ExpandProperty LocalPath -First 1
    } catch {
        # ここは続行してレジストリ方式へフォールバック
    }

    if (-not $userProfilePath) {
        # フォールバック：レジストリから探す
        $regProfiles = Get-ChildItem "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList" -ErrorAction SilentlyContinue
        foreach ($key in $regProfiles) {
            $p = Get-ItemProperty -Path $key.PSPath -Name "ProfileImagePath" -ErrorAction SilentlyContinue
            if ($p.ProfileImagePath -and ($p.ProfileImagePath -match "\\$currentUser$")) {
                $userProfilePath = $p.ProfileImagePath
                break
            }
        }
    }

    if (-not $userProfilePath) {
        Write-Log "ERROR: ユーザープロファイルのパスが特定できませんでした。処理を中止します。"
        throw "User profile path not found."
    }

    Write-Log "ターゲットプロファイルパス: $userProfilePath"

    # ------------------------------
    # 3) 安全チェック：組み込みアカウントや想定外パスは拒否
    # ------------------------------
    $lowerPath = $userProfilePath.ToLowerInvariant()
    $blocked = @("c:\users\administrator", "c:\users\default", "c:\users\defaultuser0", "c:\users\public", "c:\windows")
    foreach ($b in $blocked) {
        if ($lowerPath -like "$b*") {
            Write-Log "ERROR: 無効／保護対象のプロファイルを削除対象として検出しました: $userProfilePath。処理を中止します。"
            throw "Refusing to operate on protected profile: $userProfilePath"
        }
    }

    # ------------------------------
    # 4) 実際に削除するパスを組み立て（現在ログインユーザーのプロファイル配下のみ）
    # ------------------------------
    $userDataPaths = @(
        Join-Path $userProfilePath "Downloads\*",
        Join-Path $userProfilePath "Documents\*",
        Join-Path $userProfilePath "Desktop\*",
        Join-Path $userProfilePath "Pictures\*",
        Join-Path $userProfilePath "Videos\*",
        Join-Path $userProfilePath "Music\*"
    )

    Write-Log "削除対象の一覧:"
    foreach ($p in $userDataPaths) { Write-Log "  $p" }

    # ※ もし一時的にテストしたい場合は $DryRun = $true にする（削除コマンドに -WhatIf を付ける）
    $DryRun = $false
    $whatIfParam = if ($DryRun) { "-WhatIf" } else { $null }

    # ------------------------------
    # 5) ファイル削除（ログ／例外処理あり）
    # ------------------------------
    foreach ($path in $userDataPaths) {
        $parent = Split-Path $path
        if (Test-Path $parent) {
            try {
                if ($DryRun) {
                    Write-Log "DryRun: Remove-Item -Path '$path' -Recurse -Force -ErrorAction Stop -WhatIf"
                } else {
                    Remove-Item -Path $path -Recurse -Force -ErrorAction Stop
                    Write-Log "削除成功: $path"
                }
            } catch {
                Write-Log "削除失敗: $path - $($_.Exception.Message)"
            }
        } else {
            Write-Log "存在しないためスキップ: $parent"
        }
    }

    # Chrome のユーザーデータ（対象プロファイルのローカル/ローミング）
    $chromeLocal = Join-Path $userProfilePath "AppData\Local\Google\Chrome\User Data"
    $chromeRoaming = Join-Path $userProfilePath "AppData\Roaming\Google\Chrome"

    foreach ($path in @($chromeLocal, $chromeRoaming)) {
        if (Test-Path $path) {
            try {
                if ($DryRun) {
                    Write-Log "DryRun: Remove-Item -Path '$path' -Recurse -Force -ErrorAction Stop -WhatIf"
                } else {
                    Remove-Item -Path $path -Recurse -Force -ErrorAction Stop
                    Write-Log "削除成功: $path"
                }
            } catch {
                Write-Log "削除失敗: $path - $($_.Exception.Message)"
            }
        } else {
            Write-Log "Chrome データが見つかりませんでした: $path"
        }
    }

    # 一時ファイルはユーザーの TEMP を削除（管理者コンテキストの TEMP を誤って消さない）
    $userTemp = Join-Path $userProfilePath "AppData\Local\Temp\*"
    try {
        if (Test-Path (Split-Path $userTemp)) {
            if ($DryRun) {
                Write-Log "DryRun: Remove-Item -Path '$userTemp' -Recurse -Force -ErrorAction SilentlyContinue -WhatIf"
            } else {
                Remove-Item -Path $userTemp -Recurse -Force -ErrorAction SilentlyContinue
                Write-Log "一時ファイル削除完了: $userTemp"
            }
        } else {
            Write-Log "ユーザー TEMP が見つかりません: $userTemp"
        }
    } catch {
        Write-Log "一時ファイル削除中のエラー: $($_.Exception.Message)"
    }

    Write-Log "=== クリーンアップ完了 ==="

} catch {
    Write-Log "エラー発生: $($_.Exception.Message)"
}



導入手順
1. スクリプトの配置

管理者としてPowerShellを起動
スクリプトを非表示の場所に保存：

powershell# スクリプト保存先ディレクトリを作成
New-Item -Path "C:\Windows\System32\Scripts" -ItemType Directory -Force

# スクリプトをメモ帳で作成
notepad C:\Windows\System32\Scripts\CleanupUserData.ps1

上記のスクリプトをコピー＆ペーストして保存

2. 実行ポリシーの設定
powershell# PowerShellスクリプトの実行を許可
Set-ExecutionPolicy RemoteSigned -Scope LocalMachine -Force
3. タスクスケジューラの設定
シャットダウン時に実行する場合：
powershell# シャットダウン時のタスク作成
$action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "-ExecutionPolicy Bypass -WindowStyle Hidden -File C:\Windows\System32\Scripts\CleanupUserData.ps1"

$trigger = New-ScheduledTaskTrigger -AtLogOff

$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -RunLevel Highest

$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries

Register-ScheduledTask -TaskName "UserDataCleanup_Shutdown" -Action $action -Trigger $trigger -Principal $principal -Settings $settings -Description "シャットダウン時にユーザーデータを削除"
起動時に実行する場合：
powershell# 起動時のタスク作成
$action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "-ExecutionPolicy Bypass -WindowStyle Hidden -File C:\Windows\System32\Scripts\CleanupUserData.ps1"

$trigger = New-ScheduledTaskTrigger -AtStartup

$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -RunLevel Highest

$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries

Register-ScheduledTask -TaskName "UserDataCleanup_Startup" -Action $action -Trigger $trigger -Principal $principal -Settings $settings -Description "起動時にユーザーデータを削除"
4. 動作確認
powershell# 手動でタスクを実行してテスト
Start-ScheduledTask -TaskName "UserDataCleanup_Startup"

# ログを確認
Get-Content C:\Windows\System32\CleanupLog.txt
注意事項
⚠️ 重要な警告：

データは完全に削除されます - 復元できません
テスト環境で十分に検証してください
バックアップが必要なデータは別の場所に保存してください
業務環境で使用する場合は、組織のポリシーを確認してください

オプション設定
特定のフォルダを除外する場合：
スクリプト内の削除対象を調整：
powershell# 例：Documentsフォルダは削除しない場合
$userDataPaths = @(
    "$userProfile\Downloads\*",
    # "$userProfile\Documents\*",  # コメントアウト
    "$userProfile\Desktop\*"
)
複数ユーザーに対応する場合：
全ユーザーを対象にする場合は、スクリプトの先頭に追加：
powershell# 全ユーザーのプロファイルを取得
$users = Get-ChildItem "C:\Users" -Directory | Where-Object { $_.Name -ne "Public" }

foreach ($user in $users) {
    $userProfile = $user.FullName
    # 以降の処理...
}
